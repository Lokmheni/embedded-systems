/**
 * @file graphics.c
 * @author Simon Th√ºr and Lokman Mheni
 * @brief
 * @version 0.1
 * @date 2022-12-02
 *
 * @copyright Copyright (c) 2022
 *
 */


#include "graphics.h"
#include <nds.h>
#include "paysage.h"
#include "player.h"
#include "play_mode.h"
#include "player2.h"
#include "../io/input.h"
#include "streetfighter.h"
#include <math.h>
#include "numbers.h"
#include "string.h"
#include "chrono_display.h"

#include "../game/game_controller.h"

#define	SPRITE_WIDTH	32
#define	SPRITE_HEIGHT	32

#define	RED   ARGB16(1,31,0,0)
#define	GREEN ARGB16(1,0,31,0)
#define	BLUE  ARGB16(1,0,0,31)
#define	WHITE ARGB16(1,31,31,31)
#define	BLACK ARGB16(1,0,0,0)


// int rand_ticks;

void init_screens(){
	show_logo();
	init_sub_screen();
}

void init_sub_screen() {
	// Configure the SUB engine in Rotoscale Mode
	REG_DISPCNT_SUB = MODE_5_2D | DISPLAY_BG2_ACTIVE;
	// Configure the corresponding VRAM memory bank correctly
	VRAM_C_CR = VRAM_ENABLE | VRAM_C_SUB_BG;
	// Configure background BG2 in rotoscale mode using 8bit pixels
	BGCTRL_SUB[2] = BG_BMP_BASE(0) | BG_BMP8_256x256;
	// Transfer image and palette to the corresponding memory locations
	swiCopy(play_modeBitmap, BG_GFX_SUB, play_modeBitmapLen/2);
	swiCopy(play_modePal, BG_PALETTE_SUB, play_modePalLen/2);
	// Set up affine matrix
	REG_BG2PA_SUB = 256;
	REG_BG2PC_SUB = 0;
	REG_BG2PB_SUB = 0;
	REG_BG2PD_SUB = 256;
}


void show_logo(){
	// 1) VRAM Configuration for MAIN engine
	VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;
	// 2) Main engine configuration in rotoscale mode
	REG_DISPCNT = MODE_5_2D | DISPLAY_BG2_ACTIVE | DISPLAY_BG0_ACTIVE;
	// 3) Configure the background
	BGCTRL[2] = BG_BMP_BASE(0) | BG_BMP8_256x256;
	// 4) Copy bitmap and palette generated by grit
	swiCopy(streetfighterBitmap, BG_GFX, streetfighterBitmapLen/2);
	swiCopy(streetfighterPal, BG_PALETTE, streetfighterPalLen/2);
	//Affine Marix Transformation
	bgTransform[2]->xdx = 1*256;
	bgTransform[2]->ydx = 0*256;
	bgTransform[2]->xdy = 0*256;
	bgTransform[2]->ydy = 1*256;
	bgTransform[2]->dx = 0*256;
	bgTransform[2]->dy = 0*256;
}

void init_main_screen(Player* t){
	REG_DISPCNT = MODE_5_2D | DISPLAY_BG0_ACTIVE;
	//Activate and configure VRAM bank to work in background mode
	VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;
	VRAM_G_CR = VRAM_ENABLE | VRAM_G_MAIN_SPRITE_0x06400000;
	//BG0 configuration for the background
	BGCTRL[0] = BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1) | BG_32x32;
	//Copy data to display background (tiles, palette and map)
	swiCopy(paysageTiles, BG_TILE_RAM(1), paysageTilesLen/2);
	swiCopy(paysagePal, BG_PALETTE, paysagePalLen/2);
	swiCopy(paysageMap, BG_MAP_RAM(0), paysageMapLen/2);
	//sprite_pos_local(t);
	//sprite_pos_remote(t);
	//configureSprites();
}

int min = 0, sec = 0, msec = 0;

void ISR_TIMER0(){
	msec = (msec + 1)%1000;
	if(msec == 0)
	{
		sec = (sec+1) % 60;
		if(sec == 0)
			min++;
	}
	if(sec >= 10)
		//The background color is ste to BLACK and the digits color is set to RED
		changeColorDisp(BLACK, RED);
	updateChronoDisp(BG_MAP_RAM_SUB(0), min, sec, msec);
}


void show_timer(){

	 // using tiled mode? YES!

	//Enable a suitable VRAM block and map it to the sub engine
	VRAM_H_CR = VRAM_ENABLE
			| VRAM_H_SUB_BG;
	//Configure the engine in Mode 0 and use the BG0
	REG_DISPCNT_SUB = MODE_0_2D | DISPLAY_BG0_ACTIVE;
	//Configure the engine to be used as a 32x32 grid of tiles of 256 colors
	//Use BG_MAP_BASE(0) and  a suitable BG_TILE_BASE
	BGCTRL_SUB[0] = BG_32x32 | BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1);

	//Copy the tiles and the palette to the corresonding location
	swiCopy(numbersTiles, BG_TILE_RAM_SUB(1), numbersTilesLen);
	swiCopy(numbersPal, BG_PALETTE_SUB, numbersPalLen);

    //min = sec = msec = 0;
	TIMER_DATA(0) = TIMER_FREQ_1024(1000);
	TIMER0_CR = TIMER_ENABLE | TIMER_DIV_1024 | TIMER_IRQ_REQ;
	irqSet(IRQ_TIMER0, &ISR_TIMER0);
	irqEnable(IRQ_TIMER0);
	changeColorDisp(WHITE, BLACK);
    //The value 12:34.567 is going to be printed in the center of the screen
    //updateChronoDisp(BG_MAP_RAM_SUB(0), min, sec, msec);

	//The digit 8 is printed in the upper left part of the screen
	printDigit(BG_MAP_RAM_SUB(0), 8,0,0);
}

//void sprite_pos_local(PlayerState* const player) {}

//void sprite_pos_remote(PlayerState* const player) {}

void change_background() {}

void set_background(int new_background) {}

void set_time_remaining(int min, int sec, int msec) {}

void show_settings(int games_played, int games_won) {}


void sprite_pos_local(Player* const player) {
	u16* gfx;
	u16* gfx1;
	// Set up memory bank to work in sprite mode (offset since we are using VRAM
	// A for backgrounds)
	VRAM_G_CR = VRAM_ENABLE | VRAM_G_MAIN_SPRITE_0x06400000;
	//VRAM_G_CR = VRAM_ENABLE | VRAM_G_MAIN_SPRITE_0x06400000;
	// Initialize sprite manager and the engine
	oamInit(&oamMain, SpriteMapping_1D_32, false);
	// Allocate space for the graphic to show in the sprite
	gfx =
		oamAllocateGfx(&oamMain, SpriteSize_32x32, SpriteColorFormat_256Color);
	gfx1 =
		oamAllocateGfx(&oamMain, SpriteSize_32x32, SpriteColorFormat_256Color);

	// Copy data for the graphic (palette and bitmap)
	dmaCopy(playerPal, &SPRITE_PALETTE[player2PalLen/2 + 1], playerPalLen);
	dmaCopy(playerTiles, gfx, playerTilesLen);
	dmaCopy(player2Pal, SPRITE_PALETTE, player2PalLen);
	dmaCopy(player2Tiles, gfx1, player2TilesLen);

   //printf("BEGIN\n");
   while (1)
   {
	   //printf("set stage\n");
	   set_stage();
	   swiWaitForVBlank();
	   //printf("configure sprites\n");
	   //configureSprites();
	   //printf("done with sprites\n");
	   // while (!wifi_connect_network())
	   //     {
	   //         printf("failed to connect\n");
	   //         int i;
	   //         for (i = 0; i < 50; i++)
	   //             {
	   //                 swiWaitForVBlank();
	   //             }
	   //     }
	   //printf("connected\n");
	   wifi_announce_lfg();
	   //printf("sent lfg\n");
	   bool    game = false;
	   WifiMsg msg;
	   // wait for game
	   // while (!game)
	   //     {
	   //         game = receive_messages(&msg);
	   //     }
	   //printf("receifved msg\n");
	   if (msg.msg == WIFI_REQ_LFG)
	   {
		   send_ctrl_instruction(
		   START_GAME | IS_PLAY | SET_STAGE | RESET_GAME, 0);
		 //  printf("sent start command\n");
		}
		reset_game();
		u32 keys;
		//printf("start game\n");

		while (1) // game
		{
			RequestedAction   a;
			RequestedMovement m;
			a = REQ_ACTION_NONE;
			scanKeys();
			keys = keysHeld();
			if (keys & KEY_A)
			{
				a = REQ_ACTION_JUMP;
			//	printf("Key pressed A\n");
			}
			if (keys / KEY_Y)
			{
				a = REQ_ACTION_BLOCK;
				//printf("Key pressed Y\n");
			}
			if (keys & KEY_X)
			{
				a = REQ_ACTION_ATTACK;
			}
			m = REQ_MOVE_NONE;
			if (keys & KEY_LEFT)
			{
				m = REQ_MOVE_LEFT;
				//printf("Key pressed left\n");
			}
			if (keys & KEY_RIGHT)
			{
				m = REQ_MOVE_RIGHT;
				//printf("Key pressed right\n");
			}

			if (receive_messages(&msg))
			{
				//printf("received wifi msg\n");
				update_game(a, m, msg);
			}
			else
			{
				msg.msg = WIFI_NULL_MSG;
				update_game(a, m, msg);
			}
			Player l = get_player_local();
			send_status(&l);
			// print_players();
			// configureSprites();
			oamSet(&oamMain, // oam handler
			   0,        // Number of sprite
			   get_player_local().pos_x,
			   get_player_local().pos_y, // Coordinates
			   //    get_player_remote().pos_x,
			   //    get_player_remote().pos_y,  // Coordinates
			   0,                          // Priority
			   0,                          // Palette to use
			   SpriteSize_32x32,           // Sprite size
			   SpriteColorFormat_256Color, // Color format
			   gfx,          // Loaded graphic to display
			   -1,           // Affine rotation to use (-1 none)
			   false,        // Double size if rotating
			   false,        // Hide this sprite
			   false, false, // Horizontal or vertical flip
			   false         // Mosaic
			);
			// Update the sprites


			// int i;
			// for (i = 0; i < 25; i++)
			//     {
			//         swiWaitForVBlank();
			//     }
			swiWaitForVBlank();
			oamUpdate(&oamMain);
		  }
	}
}

void sprite_pos_remote(Player* const player){
	u16* gfx1;
	//Set up memory bank to work in sprite mode (offset since we are using VRAM A for backgrounds)
	VRAM_G_CR = VRAM_ENABLE | VRAM_G_MAIN_SPRITE_0x06400000;
	//Initialize sprite manager and the engine
	oamInit(&oamMain, SpriteMapping_1D_32, false);
	//Allocate space for the graphic to show in the sprite
	gfx1 = oamAllocateGfx(&oamMain, SpriteSize_32x32, SpriteColorFormat_256Color);
	//Copy data for the graphic (palette and bitmap)
	dmaCopy(player2Pal, SPRITE_PALETTE, player2PalLen);
	dmaCopy(player2Tiles, gfx1, player2TilesLen);

	while(1){
		oamSet(&oamMain, // oam handler
				1,        // Number of sprite
				translate_remote_x(get_player_remote().pos_x),
				get_player_remote().pos_y,  // Coordinates
				0,                          // Priority
				3,                          // Palette to use
				SpriteSize_32x32,           // Sprite size
				SpriteColorFormat_256Color, // Color format
				gfx1,         // Loaded graphic to display
				-1,           // Affine rotation to use (-1 none)
				false,        // Double size if rotating
				false,        // Hide this sprite
				false, false, // Horizontal or vertical flip
				false         // Mosaic
			);
		swiWaitForVBlank();
		oamUpdate(&oamMain);
	}
}





/*void configureSprites() {
	u16* gfx;
	u16* gfx1;
	// Set up memory bank to work in sprite mode (offset since we are using VRAM
	// A for backgrounds)
	VRAM_G_CR = VRAM_ENABLE | VRAM_G_MAIN_SPRITE_0x06400000;
	//VRAM_G_CR = VRAM_ENABLE | VRAM_G_MAIN_SPRITE_0x06400000;

	// Initialize sprite manager and the engine
	oamInit(&oamMain, SpriteMapping_1D_32, false);
	// Allocate space for the graphic to show in the sprite
	gfx =
		oamAllocateGfx(&oamMain, SpriteSize_32x32, SpriteColorFormat_256Color);
	gfx1 =
		oamAllocateGfx(&oamMain, SpriteSize_32x32, SpriteColorFormat_256Color);


	// Copy data for the graphic (palette and bitmap)
	dmaCopy(playerPal, &SPRITE_PALETTE[player2PalLen/2 + 1], playerPalLen);
	dmaCopy(playerTiles, gfx, playerTilesLen);

	dmaCopy(player2Pal, SPRITE_PALETTE, player2PalLen);
	dmaCopy(player2Tiles, gfx1, player2TilesLen);


   //printf("BEGIN\n");
   for (;;)
   {
	   //printf("set stage\n");
	   set_stage();
	   swiWaitForVBlank();
	   //printf("configure sprites\n");
	   //configureSprites();
	   //printf("done with sprites\n");
	   // while (!wifi_connect_network())
	   //     {
	   //         printf("failed to connect\n");
	   //         int i;
	   //         for (i = 0; i < 50; i++)
	   //             {
	   //                 swiWaitForVBlank();
	   //             }
	   //     }
	   //printf("connected\n");
	   wifi_announce_lfg();
	   //printf("sent lfg\n");
	   bool    game = false;
	   WifiMsg msg;
	   // wait for game
	   // while (!game)
	   //     {
	   //         game = receive_messages(&msg);
	   //     }
	   //printf("receifved msg\n");
	   if (msg.msg == WIFI_REQ_LFG)
	   {
		   send_ctrl_instruction(
		   START_GAME | IS_PLAY | SET_STAGE | RESET_GAME, 0);
		 //  printf("sent start command\n");
		}
		reset_game();
		u32 keys;
		//printf("start game\n");


		for (;;) // game
		{
			RequestedAction   a;
			RequestedMovement m;
			a = REQ_ACTION_NONE;
			scanKeys();
			keys = keysHeld();
			if (keys & KEY_A)
			{
				a = REQ_ACTION_JUMP;
			//	printf("Key pressed A\n");
			}
			if (keys / KEY_Y)
			{
				a = REQ_ACTION_BLOCK;
				//printf("Key pressed Y\n");
			}
			if (keys & KEY_X)
			{
				a = REQ_ACTION_ATTACK;
			}
			m = REQ_MOVE_NONE;
			if (keys & KEY_LEFT)
			{
				m = REQ_MOVE_LEFT;
				//printf("Key pressed left\n");
			}
			if (keys & KEY_RIGHT)
			{
				m = REQ_MOVE_RIGHT;
				//printf("Key pressed right\n");
			}


			if (receive_messages(&msg))
			{
				//printf("received wifi msg\n");
				update_game(a, m, msg);
			}
			else
			{
				msg.msg = WIFI_NULL_MSG;
				update_game(a, m, msg);
			}
			Player l = get_player_local();
			send_status(&l);
			// print_players();

			//configureSprites();


			oamSet(&oamMain, // oam handler
			   0,        // Number of sprite
			   get_player_local().pos_x,
			   get_player_local().pos_y, // Coordinates
			   //    get_player_remote().pos_x,
			   //    get_player_remote().pos_y,  // Coordinates
			   0,                          // Priority
			   0,                          // Palette to use
			   SpriteSize_32x32,           // Sprite size
			   SpriteColorFormat_256Color, // Color format
			   gfx,          // Loaded graphic to display
			   -1,           // Affine rotation to use (-1 none)
			   false,        // Double size if rotating
			   false,        // Hide this sprite
			   false, false, // Horizontal or vertical flip
			   false         // Mosaic
			);
			// Update the sprites


			oamSet(&oamMain, // oam handler
			   1,        // Number of sprite
			   translate_remote_x(get_player_remote().pos_x),
			   get_player_remote().pos_y,  // Coordinates
			   0,                          // Priority
			   3,                          // Palette to use
			   SpriteSize_32x32,           // Sprite size
			   SpriteColorFormat_256Color, // Color format
			   gfx1,         // Loaded graphic to display
			   -1,           // Affine rotation to use (-1 none)
			   false,        // Double size if rotating
			   false,        // Hide this sprite
			   false, false, // Horizontal or vertical flip
			   false         // Mosaic
			);

			// int i;
			// for (i = 0; i < 25; i++)
			//     {
			//         swiWaitForVBlank();
			//     }
			swiWaitForVBlank();
			oamUpdate(&oamMain);
		  }
	}
}*/

